# 要件定義（Ethiraj & Levinthal 2004 再現）

## 0. 背景とゴール
- **ゴール1**: Ethiraj & Levinthal (2004) の「ほぼ分解可能システム＋モジュール誤認」モデルを NK ランドスケープ上で再現する。
- **ゴール2**: モジュール（真の構造 or デザイナー構造）をプレイヤーとみなし、協力ゲームの特性関数 \(v(S)\) を計算してゲームテーブルを出力する。
- **前提**: docs/papers/Ethiraj2004/modeling.html に示された 11 ステップ（真の構造／モジュール誤認／ローカル探索／リコンビネーション／ゲーム化）を基礎に、既存 Lazer/Levinthal 実装フレームワークと整合性を保つ。

## 1. 機能要件
1. **モジュラーニューラル NK ランドスケープ生成**
   - N（意思決定数）、真のモジュール数 M、モジュール内・間の依存密度を指定し、隣接行列 \(A_{true}\) と局所貢献テーブル \(f_i\) を生成。
2. **デザイナー認識（モジュール誤認）**
   - デザイナーが信じるモジュール数 K と分割 𝓓 を生成。
   - K≠M を設定し、過度/過小モジュール化シナリオを再現可能にする。
3. **マルチ企業ダイナミクス**
   - 複数企業 L の設計ベクトルを並列に更新。
   - 各モジュールに対して局所探索（F_k(d) を改善するビット反転）を実行。
4. **リコンビネーション戦略**
   - firm-level, module-level, hybrid を選択できるコピー戦略を実装。
   - 指定周期で発火させる設定をサポート。
5. **ゲームテーブル生成**
   - 真のモジュール or デザイナーモジュールをプレイヤー集合とし、ベースライン形態 d⁰ と成熟形態 d* を使って `v(S) = F(d^S) - F(d⁰)` を計算。
   - coalition_id, members, size, v_value, absolute_fitness, scenario notes をカラムに含める。
6. **CLI 連携**
   - 既存 `nk-games run` 経由で Ethiraj シナリオを起動し、config から `scenario.type = ethiraj2004` を読み取って分岐する。

## 2. 非機能要件
- **再利用性**: Landscape/CLI 基盤は既存コードと共有。Ethiraj 固有ロジックは独立モジュールで管理。
- **再現性**: 乱数シードを設定可能にし、 runs × snapshots を同一 seed で再現できるようにする。
- **可観測性**: シミュレーション履歴（平均性能など）を `outputs/logs/` に保存できる hook を提供（最低限 CSV に scenario 情報を記録）。
- **性能**: M, K ≦ 6 程度を標準とし、全提携列挙が可能なサイズに抑える。

## 3. 制約条件
- Python 3.11+ / Poetry 環境。
- 依存ライブラリは numpy, pandas, networkx, PyYAML の範囲内（追加する場合は正当化）。

## 4. 受入基準
- 基準設定（例: N=12, M=3, K=3, L=10）でダイナミクスが走り、出力 CSV `outputs/tables/ethiraj2004_baseline.csv` が生成される。
- K≠M の config に差し替えるだけで「誤認モジュラリティ」のゲームテーブルが取得できる。
- CLI `poetry run nk-games run --config config/ethiraj2004_baseline.yml` が成功する。

## 5. 実世界での解釈（プレイヤーと v(S)）

- プレイヤ = 製品・組織システムの「モジュール」（技術サブシステムや機能ブロック、あるいは設計者がそう捉えている単位）。
- d⁰ は「ベースラインの設計」（既存製品・標準設計）、d* はモジュール誤認を含むダイナミクスの結果として得られた「成熟設計」を表す。
- 提携 S は「十分に設計し直すことができたモジュール集合」とみなし、v(S) = F(d^S) − F(d⁰) は、
  『ベースラインから見て、S に属するモジュールをきちんと設計し直すことでシステム性能がどれだけ改善するか』を定量化した値として解釈できる。
