# 要件定義（Levinthal 1997 再現）

## 0. 背景とゴール
- **ゴール1**: Levinthal (1997) が提示した NK ランドスケープ上のローカル探索（適応歩行）を再現できる実験エンジンを構築する。
- **ゴール2**: 「設計権限ゲーム」解釈により、プレイヤ集合 \(N_g\) の各提携 \(S \subseteq N_g\) に特性関数 \(v(S)\) を割り当て、貢献度指標解析（Shapley 値など）の入力テーブルを生成する。
- **前提**: docs/papers/Levinthal1997/modeling.html で整理されたレイヤ構造（ランドスケープ／ローカル探索／ゲーム化）を踏襲し、Lazer2007 実装と共通部分（NK ランドスケープ等）を再利用可能にする。

## 1. 機能要件
1. **ランドスケープ生成**
   - N, K, 依存関係、局所貢献テーブルを乱数生成し、Levinthal の rugged landscape 設定を再現する。
   - 乱数シード管理により再現性を確保する。
2. **ローカル探索ダイナミクス**
   - 制約付き 1 ビット反転の山登りを実装し、「設計権限を持つビット集合 S」だけを探索できるようにする。
   - 停止条件（改善が無いステップ数、最大ステップ）とノイズ受容率をパラメータ化する。
3. **ゲーム定義**
   - プレイヤ = ビット（もしくはビット集合）対応を標準とし、提携 S のみが自由に操作できる設定をサポートする。
   - ベースライン形態 \( \bar{x} \) を固定し、S 以外のビットは固定される。
4. **特性関数推定**
   - 各提携 S について M 回の初期状態サンプリング + ローカル探索を実施し、最終フィットネスの平均・分散を記録する。
   - 複数ランドスケープの平均化（オプション）にも拡張できる構造にする。
5. **ゲームテーブル生成**
   - coalition_id, members, size, v_mean, v_std などのカラムを持つ CSV/DF を出力する。
   - Lazer2007 テーブルと同様に `outputs/tables/` へ保存し、Shapley 計算に利用できるフォーマットを保つ。
6. **CLI 統合**
   - 既存 `nk-games` CLI から Levinthal シナリオを呼び出せるようにし、設定ファイル（YAML）でシナリオ種別を切り替えられるようにする。

## 2. 非機能要件
- **再利用性**: NK ランドスケープやテーブル出力など共通基盤は Lazer2007 と共有し、レイヤ差分のみを追加実装する。
- **再現性**: ランドスケープ生成、初期状態、ローカル探索乱数のシードを設定可能にする。
- **性能**: プレイヤ数 10〜12、提携 2^N の計算に耐えるよう、単純な Python 実装でも支障のないパラメータ（N≦12, M≦32 等）を推奨する。
- **可搬性**: Poetry で依存管理し、CLI コマンド 1 本で結果ファイルを得られるようにする。

## 3. 制約条件
- Python 3.11+ / Poetry ベースで実装する。
- 依存ライブラリは既存プロジェクトと同一（numpy, pandas, networkx）に留め、追加ライブラリは必要最小限とする。

## 4. 受入基準
- Levinthal 設定（例: N=10, K=3）でローカル探索を実行し、平均フィットネス向上が可視化できる。
- 提携列挙によりゲームテーブル CSV が生成される。
- Lazer2007 用と Levinthal 用の設定ファイルを切り替えつつ同じ CLI で実行できる。

## 5. 実世界での解釈（プレイヤーと v(S)）

- プレイヤ = 組織設計の「ビット」（報酬ルール、意思決定プロセス、構造的な Yes/No などの設計レバー）。
- 提携 S は「自由に動かせる設計レバーの集合」であり、S に含まれない要素はベースライン形態 \(\bar{x}\) に固定される。
- v(S) は、「S だけを動かせる条件で山登り的な改善を繰り返したとき、どの程度まで性能を押し上げられるか」という期待値であり、
  『どのレバー集合に設計権限を与えると、全体の適応力がどれだけ高まるか』を測る指標として解釈できる。
