<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>NKモデル × ネットワーク探索・活用 – モデル設計方針スライド</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 0;
    }
    .slide {
      width: 960px;
      margin: 40px auto;
      padding: 40px 50px;
      background: #ffffff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      box-sizing: border-box;
      page-break-after: always;
    }
    h1, h2, h3 {
      margin-top: 0;
    }
    h1 { font-size: 32px; }
    h2 { font-size: 26px; }
    h3 { font-size: 20px; }
    ul {
      margin-top: 8px;
      padding-left: 1.2em;
    }
    li { margin-bottom: 6px; }
    .small {
      font-size: 13px;
      color: #666;
      margin-top: 16px;
    }
    .highlight {
      background: #fffbe6;
      padding: 3px 6px;
      border-radius: 4px;
    }
    .badge {
      display: inline-block;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 999px;
      background: #eef2ff;
      margin-right: 4px;
    }
    .cols {
      display: flex;
      gap: 32px;
    }
    .col {
      flex: 1;
    }
  </style>
</head>
<body>

  <!-- 1. タイトル -->
  <section class="slide">
    <h1>NKモデル × ネットワーク探索・活用</h1>
    <h3>モデル設計方針と貢献度ゲームテーブル生成</h3>
    <ul>
      <li>Lazer &amp; Friedman (2007) のシミュレーションを<a class="highlight">再現可能</a>な形で実装</li>
      <li>同一フレームワークから<a class="highlight">協力ゲームの特性関数 v(S)</a>を生成し、貢献度指標分析に接続</li>
      <li>NKモデル採用報告書で整理した方針を、実装可能なレベルに落とし込む</li>
    </ul>
    <p class="small">
      ゴール：ネットワーク構造・複雑性・個人差・相性を統合的に扱える実験プラットフォームを構築する。
    </p>
  </section>

  <!-- 2. ゴールの整理 -->
  <section class="slide">
    <h2>ゴールとアウトプット</h2>
    <h3>ゴール</h3>
    <ul>
      <li>G1：Lazer-Friedman 型「探索／活用 × ネットワーク構造」の挙動を NK で再現</li>
      <li>G2：プレイヤー集合 N に対して協力ゲーム
        <span class="highlight">v: 2<sup>N</sup> → ℝ</span>
        のゲームテーブルを自動生成
      </li>
      <li>G3：Shapley値など貢献度指標を計算し、「技量差・相性・構造」の影響を評価</li>
    </ul>
    <h3>最終アウトプット</h3>
    <ul>
      <li>全提携 S ⊆ N に対する v(S) を持つ <strong>ゲームテーブル（CSV / DataFrame）</strong></li>
      <li>実験条件（N, K, ネットワーク種別, velocity, error, skill構成 等）のメタデータ</li>
    </ul>
  </section>

  <!-- 3. レイヤ構造の全体像 -->
  <section class="slide">
    <h2>全体アーキテクチャ：5レイヤ構造</h2>
    <ul>
      <li><span class="badge">Layer A</span> NKランドスケープ（環境）
        <ul>
          <li>Nビット・K依存の状態空間とスコア関数 V(d)</li>
        </ul>
      </li>
      <li><span class="badge">Layer B</span> エージェント＆タスク割当
        <ul>
          <li>エージェントと担当ビット・スキル属性の定義</li>
        </ul>
      </li>
      <li><span class="badge">Layer C</span> ネットワーク構造
        <ul>
          <li>line / complete / random / small-world など</li>
        </ul>
      </li>
      <li><span class="badge">Layer D</span> 探索・活用ダイナミクス
        <ul>
          <li>模倣＋近傍探索、velocity・error パラメータ</li>
        </ul>
      </li>
      <li><span class="badge">Layer E</span> ゲーム化 &amp; ゲームテーブル生成
        <ul>
          <li>提携 S ごとに v(S) を実験的に測定</li>
        </ul>
      </li>
    </ul>
    <p class="small">
      Lazer-Friedman「純正設定」はこの5レイヤの特殊ケースとして実装する。
    </p>
  </section>

  <!-- 4. Layer A：NKランドスケープ設計 -->
  <section class="slide">
    <h2>Layer A：NKランドスケープ（環境）</h2>
    <div class="cols">
      <div class="col">
        <h3>数理定義</h3>
        <ul>
          <li>状態：
            <span class="highlight">d = (d<sub>1</sub>, …, d<sub>N</sub>) ∈ {0,1}<sup>N</sup></span>
          </li>
          <li>依存先：Dep(i) = {i<sub>1</sub>, …, i<sub>K</sub>}</li>
          <li>局所スコア：
            c<sub>i</sub> = f<sub>i</sub>(d<sub>i</sub>, d<sub>i1</sub>, …, d<sub>iK</sub>) ∈ [0,1]
          </li>
          <li>全体スコア：
            V(d) = (1/N) Σ c<sub>i</sub>
          </li>
        </ul>
      </div>
      <div class="col">
        <h3>実装イメージ（クラス）</h3>
        <ul>
          <li><code>NKLandscape(N, K, seed)</code></li>
          <li>属性：
            <ul>
              <li><code>dependencies[i] → List[int]</code></li>
              <li><code>tables[i] → 長さ 2**(K+1) の配列</code></li>
            </ul>
          </li>
          <li>メソッド：
            <ul>
              <li><code>generate_landscape()</code></li>
              <li><code>evaluate(state) → V(state)</code></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
    <p class="small">
      標準モードでは全テーブルを U[0,1] から生成。拡張でバイアス・相性を埋め込む。
    </p>
  </section>

  <!-- 5. スキル・相性のバイアスフック -->
  <section class="slide">
    <h2>Layer A 拡張：技量差・相性の埋め込み</h2>
    <h3>技量（スキル）バイアス</h3>
    <ul>
      <li>各ビット i に対して skill を割り当て：
        <ul>
          <li>Senior：c<sub>i</sub> ~ U[0.5, 1.0]</li>
          <li>Junior：c<sub>i</sub> ~ U[0.0, 0.8]</li>
        </ul>
      </li>
      <li><code>skill_profile[i] = ("Senior" or "Junior")</code></li>
      <li>テーブル生成時に skill に応じた一様分布からサンプリング</li>
    </ul>
    <h3>相性（コンフリクト）の埋め込み</h3>
    <ul>
      <li><code>conflict_pairs = [(i, j), …]</code> を指定</li>
      <li>該当ペアを含む入力パターンに対して、
        「背反的」なスコアパターンを意図的に設定
      </li>
      <li>例：A が 1, B が 0 のときだけ A 高得点／A=1,B=1 では A 低得点 など</li>
    </ul>
  </section>

  <!-- 6. Layer B：エージェントとタスク割当 -->
  <section class="slide">
    <h2>Layer B：エージェント &amp; タスク割当</h2>
    <h3>基本設計</h3>
    <ul>
      <li>エージェント集合：A = {1, …, n<sub>agents</sub>}</li>
      <li>担当ビット：
        <span class="highlight">T(a) ⊆ {1,…,N}</span>
      </li>
      <li>スキル：
        <span class="highlight">skill(a) ∈ {Senior, Junior, …}</span>
      </li>
    </ul>
    <h3>デフォルト設定（初期版）</h3>
    <ul>
      <li>1エージェント = 1ビット
        <ul>
          <li>N = n<sub>agents</sub>, T(a) = {a}</li>
        </ul>
      </li>
      <li>後続拡張：
        <ul>
          <li>ハブプレイヤー：T(a) が複数ビットを担当</li>
          <li>部署レベルのプレイヤー：複数ビットを1プレイヤーに集約</li>
        </ul>
      </li>
    </ul>
  </section>

  <!-- 7. Layer C：ネットワーク構造 -->
  <section class="slide">
    <h2>Layer C：ネットワーク構造</h2>
    <h3>対象とするネットワークタイプ</h3>
    <ul>
      <li>LINE（線形チェーン）
        <ul>
          <li>両端以外は2つの隣人のみ</li>
        </ul>
      </li>
      <li>COMPLETE（完全グラフ）
        <ul>
          <li>全員が全員と接続</li>
        </ul>
      </li>
      <li>RANDOM(p)
        <ul>
          <li>各ペアを確率 p で接続（Erdős–Rényi型）</li>
        </ul>
      </li>
      <li>SMALL_WORLD(k, β)
        <ul>
          <li>リング格子 + 再配線によるショートカット</li>
        </ul>
      </li>
    </ul>
    <h3>実装</h3>
    <ul>
      <li><code>NetworkFactory.create(type, params) → Graph</code></li>
      <li>ノード：エージェントID、エッジ：情報伝達リンク</li>
    </ul>
  </section>

  <!-- 8. Layer D：探索・活用ダイナミクス -->
  <section class="slide">
    <h2>Layer D：探索・活用ダイナミクス</h2>
    <h3>状態と更新ルール</h3>
    <ul>
      <li>各エージェント a は「自分の信じる戦略」 d<sup>a</sup> ∈ {0,1}<sup>N</sup> を保持</li>
      <li>各ラウンドで以下を並行実行：</li>
    </ul>
    <ol>
      <li>観察：
        <ul>
          <li>隣人 b ∈ N(a) のスコア V(d<sup>b</sup>) を評価</li>
          <li>自分より高い隣人がいれば最良の1人 b* を選択</li>
        </ul>
      </li>
      <li>模倣 or 探索：
        <ul>
          <li>高スコア隣人あり → d<sup>a</sup> を d<sup>b*</sup> にコピー
            （コピー誤差 e を許容）
          </li>
          <li>高スコア隣人なし → 自分の担当ビット T(a) の1ビットを反転して近傍探索</li>
        </ul>
      </li>
    </ol>
    <h3>velocity / error</h3>
    <ul>
      <li>velocity v：各ラウンドで「隣人を見る」確率（低いほど情報伝播が遅くなる）</li>
      <li>error e：コピー時のビット誤差率（高いほど多様性が維持される）</li>
    </ul>
  </section>

  <!-- 9. Layer E：ゲーム化と v(S) 定義 -->
  <section class="slide">
    <h2>Layer E：協力ゲーム化と v(S) の定義</h2>
    <h3>プレイヤー定義</h3>
    <ul>
      <li>基本案：
        <span class="highlight">プレイヤー = エージェント = ビット</span>
      </li>
      <li>プレイヤー集合 N = {1,…,n<sub>agents</sub>}</li>
    </ul>
    <h3>v(S) の定義（サブネットワーク方式）</h3>
    <ol>
      <li>S ⊆ N を与える</li>
      <li>G の誘導部分グラフ G[S] を構成（S だけが存在する組織）</li>
      <li>NKランドスケープは共通（同じ環境）</li>
      <li>T ラウンドシミュレーションを R 回実行</li>
      <li>性能指標の例：
        <ul>
          <li>最終ラウンド平均スコア：
            v(S) = (1/|S|) Σ<sub>a∈S</sub> V(d<sup>a</sup><sub>T</sub>)
          </li>
          <li>期間内ベストスコア：
            v(S) = max<sub>t≤T</sub> max<sub>a∈S</sub> V(d<sup>a</sup><sub>t</sub>)
          </li>
        </ul>
      </li>
    </ol>
    <p class="small">
      v(S) はシミュレーション実験の統計量として定義し、そのテーブルが貢献度分析の入力となる。
    </p>
  </section>

  <!-- 10. ゲームテーブル生成フロー -->
  <section class="slide">
    <h2>ゲームテーブル生成フロー</h2>
    <ol>
      <li>環境・ネットワーク・エージェント構成を固定
        <ul>
          <li>NKランドスケープ（seed）</li>
          <li>ネットワーク種別（LINE / COMPLETE 等）</li>
          <li>skill・相性パラメータ</li>
        </ul>
      </li>
      <li>全提携 S ⊆ N を列挙（2<sup>n</sup>。n は現実的な範囲に制限）</li>
      <li>各 S について：
        <ul>
          <li>G[S] を構成し、シミュレーションを R 回実行</li>
          <li>定義した指標から v(S) を推定</li>
        </ul>
      </li>
      <li>結果をテーブルに格納
        <ul>
          <li>列例：coalition_id, members, size, v_mean, v_std, params…</li>
        </ul>
      </li>
    </ol>
    <p class="small">
      このテーブルを Shapley値や他の貢献度指標への入力として利用する。
    </p>
  </section>

  <!-- 11. Lazer-Friedman再現モードと拡張 -->
  <section class="slide">
    <h2>LF再現モードと研究用拡張</h2>
    <h3>LFベースライン設定</h3>
    <ul>
      <li>N = 20, K = 5（代表ケース）</li>
      <li>n<sub>agents</sub> = N, 1人1ビット</li>
      <li>skill バイアスなし、conflict_pairs なし</li>
      <li>ネットワーク：LINE / COMPLETE / RANDOM / SMALL_WORLD</li>
      <li>velocity, error を論文の条件に合わせて設定</li>
    </ul>
    <h3>貢献度分析用拡張</h3>
    <ul>
      <li>ケース1：均質エージェント（ネットワーク純効果を見る）</li>
      <li>ケース2：Senior / Junior 混合（技量差の影響）</li>
      <li>ケース3：ハブ＋相性悪化（負の相互作用・足の引っ張り合い）</li>
    </ul>
  </section>

  <!-- 12. 実装タスク分割 -->
  <section class="slide">
    <h2>実装タスク分割（モジュール構成）</h2>
    <ul>
      <li>1. NKランドスケープモジュール
        <ul>
          <li><code>NKLandscape</code>：標準機能＋skill/conflict フック</li>
        </ul>
      </li>
      <li>2. エージェント &amp; ネットワークモジュール
        <ul>
          <li><code>Agent</code>：担当ビット・skill 等</li>
          <li><code>NetworkFactory</code>：line / complete / random / small-world</li>
        </ul>
      </li>
      <li>3. シミュレーションエンジン
        <ul>
          <li><code>Simulation</code>：velocity, error, T をパラメータに run()</li>
        </ul>
      </li>
      <li>4. ゲームテーブル生成モジュール
        <ul>
          <li><code>GameTableBuilder</code>：全 S 列挙 → v(S) 推定 → CSV 出力</li>
        </ul>
      </li>
    </ul>
    <p class="small">
      この分割により、Lazer-Friedman再現実験と貢献度ゲーム分析を同一基盤上で回せる。
    </p>
  </section>

</body>
</html>