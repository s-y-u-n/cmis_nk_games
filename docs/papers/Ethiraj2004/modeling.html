<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>NKモデル＋貢献度評価：モデリング方針（疑問ポイント整理版）</title>
  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #fff;
    }
    .slide {
      box-sizing: border-box;
      width: 100vw;
      height: 100vh;
      padding: 56px 72px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    h1, h2, h3 {
      margin-top: 0;
      margin-bottom: 20px;
    }
    h1 { font-size: 40px; }
    h2 { font-size: 32px; }
    h3 { font-size: 24px; }
    p  { font-size: 20px; line-height: 1.6; margin: 6px 0; }
    ul { font-size: 20px; line-height: 1.6; margin: 0 0 0 1.2em; padding: 0; }
    li { margin-bottom: 4px; }
    .small { font-size: 16px; opacity: 0.8; }
    .accent { color: #ffd85e; font-weight: 600; }
    .box {
      border-left: 4px solid #ffd85e;
      padding-left: 16px;
      margin-top: 8px;
    }
    code {
      font-family: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 0.9em;
    }
  </style>
</head>
<body>

<!-- 1. タイトル：今回の論点を明示 -->
<section class="slide" style="background:#111;">
  <h1>NKモデル＋貢献度評価のモデリング方針</h1>
  <h3>― 依存構造・辞書 f<sub>i</sub>・チームスコア・シナジー／アナジー ―</h3>
  <div class="box">
    <p>このスライドは、あなたが疑問を持っていた次の点にフォーカスしている：</p>
    <ul>
      <li>「真のモジュール構造」とは何か？</li>
      <li>相互依存行列と N<sub>i</sub>、辞書 f<sub>i</sub> にどう依存が入るのか？</li>
      <li>ベースライン・最終設計・“モジュールを入れた”状態のスコアの定義</li>
      <li>シナジー／アナジーは本当に発生するのか？</li>
    </ul>
  </div>
</section>

<!-- 2. 真のモジュール構造と相互依存行列 -->
<section class="slide" style="background:#151820;">
  <h2>1. 真のモジュール構造と相互依存行列</h2>
  <p>まず、「真のモジュール構造」を明確化する。</p>
  <ul>
    <li>意思決定要素集合：<code>{1, 2, ..., N}</code></li>
    <li>これらを、システム内部で<strong class="accent">本当に相互依存しているまとまり</strong>ごとに分割：
      <br><code>𝓜 = {M₁, ..., M_M}</code>（真のモジュール集合）
    </li>
    <li>各モジュール M<sub>k</sub> 内部の要素は<strong>相互依存が強い</strong>、モジュール間は<strong>依存が弱い</strong>。</li>
  </ul>
  <p>この構造を N×N の<strong>相互依存行列</strong>で表現する：</p>
  <ul>
    <li><code>A_true ∈ {0,1}^{N×N}</code> を用意し、<code>A_true[i,j]=1</code> を
      「変数 j が変数 i の局所貢献に効く」と定義。</li>
    <li>モジュール内ブロックは 1 が多く、モジュール間ブロックは 1 が少ない。
      <br>これが「ほぼ分解可能」な構造になる。</li>
  </ul>
</section>

<!-- 3. N_i と辞書 f_i：依存が入るポイント -->
<section class="slide" style="background:#101720;">
  <h2>2. 依存集合 N<sub>i</sub> と辞書 f<sub>i</sub></h2>
  <p>次に、あなたの最大の疑問だった「辞書に依存をどう入れているか」を整理する。</p>
  <ul>
    <li>相互依存行列から、各要素 i の依存集合を定義：
      <br><code>N_i = { j | A_true[i,j] = 1 }</code></li>
    <li>局所貢献関数：
      <br><code>f_i : {0,1}^{|N_i|} → [0,1]</code></li>
    <li>ここでの重要点：
      <div class="box">
        <p>「依存を辞書に入れる」とは、<br>
        <strong class="accent">辞書 f<sub>i</sub> の入力キーとして N<sub>i</sub> 上のビット列を使う</strong>こと。</p>
      </div>
    </li>
  </ul>
  <p>つまり：</p>
  <ul>
    <li>入力キー = <code>(d_j)_{j∈N_i}</code></li>
    <li>依存先のビットが変わるとキーが変わる → f<sub>i</sub>が返す値も変わる</li>
    <li>これにより、i の寄与が j,k,… の状態に依存する＝相互作用が入る。</li>
  </ul>
</section>

<!-- 4. f_i の具体数値例：依存が効いていることを“見る” -->
<section class="slide" style="background:#171717;">
  <h2>3. f<sub>i</sub> の具体数値例</h2>
  <p>例：i=5, 依存集合 N₅ = {5,7,8} の場合。</p>
  <p>入力は 3ビット列 (d₅, d₇, d₈)、全 2³=8通りに乱数で値を割り当てる：</p>
  <ul>
    <li>(0,0,0) → 0.12</li>
    <li>(0,0,1) → 0.85</li>
    <li>(0,1,0) → 0.34</li>
    <li>(0,1,1) → 0.90</li>
    <li>(1,0,0) → 0.11</li>
    <li>(1,0,1) → 0.48</li>
    <li>(1,1,0) → 0.77</li>
    <li>(1,1,1) → 0.23</li>
  </ul>
  <div class="box">
    <p>ここでのポイント：</p>
    <ul>
      <li>d₅=1 を固定しても、d₇,d₈ の変化で f₅ の値は大きく変わる。</li>
      <li>つまり、<strong>「d₅ の効果」は単独では定義されず、(d₇,d₈) との組合せに依存する。</strong></li>
      <li>この「入力キーに依存先ビットを含める」だけで、シナジー／アナジーの素材が生成される。</li>
    </ul>
  </div>
</section>

<!-- 5. システム性能 F(d) と「線形ではない」こと -->
<section class="slide" style="background:#131820;">
  <h2>4. システム性能 F(d) の定義</h2>
  <p>任意の設計 d ∈ {0,1}^N に対してシステム性能を：</p>
  <p><code>F(d) = (1/N) · Σ_i f_i(d|_{N_i})</code></p>
  <ul>
    <li>見た目は「平均」なので線形に見える。</li>
    <li>しかし、各項 f<sub>i</sub> が「依存ビット列 → 非線形値」の辞書なので、
      <strong>F 全体としては強い非線形・強い相互作用を持つ</strong>。</li>
  </ul>
  <div class="box">
    <p>重要な整理：</p>
    <ul>
      <li>線形重みモデル：<code>F(d) = Σ w_i d_i</code> → 相互作用なし。</li>
      <li>今回の NK 型モデル：
        <br><code>F(d) = Σ f_i(d_i, 依存先...)</code> → 組合せ依存が強烈。</li>
    </ul>
  </div>
</section>

<!-- 6. ベースライン・最終設計・“モジュール導入”状態 -->
<section class="slide" style="background:#171a22;">
  <h2>5. ベースライン／最終設計／モジュール導入状態</h2>
  <p>貢献度評価で問題になっていた「チームスコア」は、次の3種類の設計を区別するとクリアになる。</p>
  <ul>
    <li><strong>ベースライン設計 d⁰</strong>：
      <br>最も単純には <code>d⁰ = (0,...,0)</code> とし、<code>F(d⁰)</code> を基準スコアとする。</li>
    <li><strong>最終設計 d*</strong>：
      <br>NK ダイナミクスを回した結果、ある企業（または代表企業）が到達した設計。<code>F(d*)</code> は「実際のチーム成績」に相当。</li>
    <li><strong>モジュール C を「入れた」設計 d^C</strong>：
      <br>モジュール C が担当する意思決定ビットだけ d* の値を採用し、それ以外のビットは d⁰ に戻したもの。
      <br>直感的には「モジュール C だけを導入した世界の設計」。</li>
  </ul>
</section>

<!-- 7. チームスコア v(C) の定義と解釈 -->
<section class="slide" style="background:#121720;">
  <h2>6. チームスコア v(C) の定義</h2>
  <p>モジュール集合 C をプレイヤーとみなす協力ゲームの特性関数は：</p>
  <ul>
    <li>まず d^C に対して性能を計算：
      <br><code>F(d^C)</code> = 「モジュール C を導入した世界のスコア」</li>
    <li>特性関数値：
      <br><code>v(C) = F(d^C) − F(d⁰)</code></li>
  </ul>
  <div class="box">
    <p>ここで：</p>
    <ul>
      <li><strong>企業の実スコア</strong>：<code>F(d*)</code>（1つしかない）</li>
      <li><strong>ゲーム上のチームスコア</strong>：各 C についての <code>v(C)</code></li>
      <li>v(C) は「モジュール C を入れたときの成果」を、ベースラインからの上振れとして測ったもの。</li>
    </ul>
  </div>
  <p>この v(C) テーブルを元に、Shapley 値等の貢献度指標を計算する。</p>
</section>

<!-- 8. シナジー／アナジーが自然発生する理由 -->
<section class="slide" style="background:#171717;">
  <h2>7. シナジー／アナジーは発生するか？</h2>
  <p>シナジー／アナジーの定義：</p>
  <ul>
    <li>シナジー（正の相互作用）：
      <br><code>v({A,B}) > v({A}) + v({B})</code></li>
    <li>アナジー（負の相互作用）：
      <br><code>v({A,B}) < v({A}) + v({B})</code></li>
  </ul>
  <p>今回のモデルでは以下の理由で、これらが自然に（高確率で）発生する：</p>
  <ul>
    <li>f<sub>i</sub> の入力キーが N<sub>i</sub> 上のビット列であり、複数要素の組合せで値が変わる。</li>
    <li>真のモジュール構造に基づく A_true により、「どのモジュール同士が絡み合うか」が決まっている。</li>
    <li>モジュール C, D を別々に導入した場合と、C ∪ D を同時導入した場合で、辞書 f<sub>i</sub> が参照するパターンが変わる。</li>
  </ul>
  <div class="box">
    <p>結果：</p>
    <ul>
      <li>ある組合せでは v(C∪D) が v(C)+v(D) を上回る（補完的シナジー）。</li>
      <li>別の組合せでは v(C∪D) が v(C)+v(D) を下回る（干渉＝アナジー）。</li>
      <li>これは追加の“シナジー用パラメータ”を入れなくても、辞書＋依存構造だけで自動的に発生する。</li>
    </ul>
  </div>
</section>

<!-- 9. 全体像のまとめ：疑問への対応 -->
<section class="slide" style="background:#111;">
  <h2>8. 疑問への対応関係まとめ</h2>
  <ul>
    <li><strong>Q1: 真のモジュール構造とは？</strong><br>
      A: 相互依存行列 A_true に対応する「本物のブロック構造」であり、性能 F(d) を決める根本の相互作用グループ。</li>
    <li><strong>Q2: 依存は辞書にどう入る？</strong><br>
      A: 各 f<sub>i</sub> の入力キーを N<sub>i</sub> 上のビット列にし、依存先ビットが変わるとキーが変わる＝返す値が変わるようにしている。</li>
    <li><strong>Q3: チームスコアとは何か？</strong><br>
      A: モジュール集合 C だけ d* の値を採用し、他は d⁰ に戻した設計 d^C の性能 F(d^C)（ベースラインとの差分 v(C)）を指す。</li>
    <li><strong>Q4: シナジー／アナジーは発生する？</strong><br>
      A: f<sub>i</sub> の組合せ依存と A_true により、v(C∪D) ≷ v(C)+v(D) が自然に生じるため、発生する。</li>
  </ul>
  <p class="small">このモデリング方針を前提に、ゲームテーブル v(C) を生成し、Shapley 値・相互作用指数・シナジー指標を適用することで、モジュール設計と貢献度評価の関係を分析する。</p>
</section>

</body>
</html>