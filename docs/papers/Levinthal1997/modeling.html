<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>NKモデルにもとづく貢献度ゲームのモデリング方針</title>
  <style>
    body {
      font-family: system-ui, -apple-system, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      color: #222;
    }
    .slides {
      width: 960px;
      margin: 0 auto;
      padding: 24px 0 48px;
    }
    .slide {
      background: #fff;
      padding: 40px 60px;
      margin: 0 0 32px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
      page-break-after: always;
    }
    h1, h2, h3 {
      margin-top: 0;
    }
    h1 {
      font-size: 30px;
      margin-bottom: 8px;
    }
    h2 {
      font-size: 24px;
      margin-bottom: 6px;
    }
    h3 {
      font-size: 18px;
      margin-top: 20px;
      margin-bottom: 4px;
    }
    ul {
      margin-top: 6px;
    }
    li {
      margin-bottom: 6px;
      line-height: 1.5;
    }
    .note {
      margin-top: 14px;
      font-size: 13px;
      color: #666;
    }
    .figure-note {
      margin-top: 8px;
      font-size: 13px;
      color: #555;
      border-left: 3px solid #ddd;
      padding-left: 10px;
    }
    code {
      font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      background: #f0f0f0;
      padding: 2px 4px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
<div class="slides">

  <!-- Slide 1: 目的とフォーカス -->
  <section class="slide">
    <h1>NKモデルにもとづく貢献度ゲームのモデリング方針</h1>
    <h3>このスライドで整理するポイント</h3>
    <ul>
      <li><b>疑問1：</b> このアーキテクチャにおける「プレイヤー」は何か？（社内政策との対応）</li>
      <li><b>疑問2：</b> チームスコア <code>v(S)</code> は何を意味し、どう計算されるのか？</li>
      <li><b>疑問3：</b> 事前に生成した離散テーブル <code>f_i</code> と <code>v(S)</code> の違いは何か？</li>
      <li><b>疑問4：</b> なぜ「S を大きくすると必ずスコアが上がる」とは限らないのか？</li>
      <li><b>疑問5：</b> シナジー／アナジーは NK モデル上のどこから生じるのか？</li>
    </ul>
    <div class="note">
      Copilot が出してきた設計書をチェックする際の「正解モデル」を、ここで明確にしておくことが目的。
    </div>
  </section>

  <!-- Slide 2: 疑問1 プレイヤーは何か -->
  <section class="slide">
    <h2>疑問1：プレイヤーは何か？（社内政策との対応）</h2>
    <h3>モデル上の定義</h3>
    <ul>
      <li><b>プレイヤー = NKモデルのビット（属性）1つ1つ</b></li>
      <li>プレイヤ集合：<code>N_g = {1, 2, ..., N}</code></li>
      <li>ビット i は、組織設計の低レベルな要素を表現する：
        <ul>
          <li>例：意思決定ルールの一部、プロセスの分岐条件、評価制度のスイッチ等</li>
        </ul>
      </li>
    </ul>
    <h3>実世界との対応関係</h3>
    <ul>
      <li>「社内政策」そのものではなく、<b>政策を構成する設計パラメータ</b>がプレイヤー。</li>
      <li>大きな「政策パッケージ」を NK 上で扱いたい場合は、複数ビットを束ねた「プレイヤーグループ」として拡張する。</li>
    </ul>
    <div class="note">
      設計書レビュー時は「プレイヤ = ビット」になっているかをまず確認し、<br/>
      「政策 = プレイヤ」になっていないかをチェックする。
    </div>
  </section>

  <!-- Slide 3: 疑問2 v(S) の意味と計算 -->
  <section class="slide">
    <h2>疑問2：チームスコア v(S) は何か？</h2>
    <h3>意味づけ</h3>
    <ul>
      <li>提携 <code>S ⊆ N_g</code> は、「自由に変更可能なビット集合」。</li>
      <li><b>v(S) = 提携 S が持つ設計自由度のもとで、ローカル探索を行ったときに到達しうるフィットネスの期待値。</b></li>
      <li>経営的な言い換え：
        <ul>
          <li>「S のメンバーが握っている設計権限だけで、どの程度の組織パフォーマンスまで持っていけるか」の平均値。</li>
        </ul>
      </li>
      <li>売上そのものではなく、<b>抽象的な「適応度・組織パフォーマンス」指標</b>として扱う。</li>
    </ul>
    <h3>形式的定義（静的環境の場合）</h3>
    <ul>
      <li>トライアル m ごとの最終状態を <code>x_final^(m)(S)</code> とすると：
        <div class="figure-note">
          v(S) = (1/M) Σ<sub>m=1..M</sub> F(x_final^(m)(S))
        </div>
      </li>
      <li>M は「初期点サンプル数」。</li>
    </ul>
  </section>

  <!-- Slide 4: 疑問3 f_i と v(S) の違い -->
  <section class="slide">
    <h2>疑問3：離散テーブル f_i と v(S) の違いは？</h2>
    <h3>f_i（局所貢献テーブル）</h3>
    <ul>
      <li>型：<code>f_i : {0,1}^{K+1} → [0,1]</code></li>
      <li>役割：ビット i とその周辺 K ビットの組み合わせごとの「局所フィットネス」を定義。</li>
      <li>性質：
        <ul>
          <li>ランドスケープ生成時に乱数で一度だけ決める。</li>
          <li>完全に静的で、探索とは無関係に存在する「地形の形」。</li>
        </ul>
      </li>
    </ul>
    <h3>v(S)（特性関数）</h3>
    <ul>
      <li>型：<code>v : 2^{N_g} → ℝ</code></li>
      <li>役割：提携 S に対して、制約付きローカル探索の結果得られる<b>到達フィットネスの期待値</b>を返す。</li>
      <li>性質：
        <ul>
          <li>f_i が作る地形上で、初期点とローカル探索をシミュレートして初めて得られる値。</li>
          <li>地形（f_i）＋探索プロセス（山登り）＋制約（S）の<b>統合結果</b>。</li>
        </ul>
      </li>
    </ul>
    <div class="note">
      設計書では「f_i の値をそのまま足し合わせて v(S) にしていないか」を要チェック。<br/>
      v(S) はあくまで「ローカル探索 → 最終 F(x) → M 回平均」で定義される。
    </div>
  </section>

  <!-- Slide 5: 疑問2/4 v(S) のシミュレーション仕様 -->
  <section class="slide">
    <h2>疑問2の補足：v(S) のシミュレーション仕様</h2>
    <h3>1回のトライアルでやること</h3>
    <ul>
      <li>1. 初期状態生成
        <ul>
          <li>ランダムなビット列 x を生成。</li>
          <li>固定ビット <code>i ∉ S</code> はベースライン <code>baseline_x[i]</code> で上書き。</li>
        </ul>
      </li>
      <li>2. 制約付きローカル探索
        <ul>
          <li>ステップごとに <b>j ∈ S</b> から 1 ビット選び、0/1 を反転した候補 x' を生成。</li>
          <li>NK 定義通りに F(x') を計算し、改善なら採用。</li>
          <li>改善が一定回数続けて起きない／ステップ上限で停止。</li>
        </ul>
      </li>
      <li>3. 最終フィットネス
        <ul>
          <li>停止時の状態 x_final に対し、<b>NK の式そのまま</b>で F(x_final) を計算。</li>
        </ul>
      </li>
    </ul>
    <h3>v(S) の最終計算</h3>
    <ul>
      <li>上述のトライアルを m=1..M 回繰り返し、<code>v(S) = 平均(F_final^(m))</code> と定義。</li>
    </ul>
    <div class="note">
      Copilot の設計書では、「S に応じて free_bits / fixed_bits が正しく分離されているか」「F の計算が NK 定義と一致しているか」を重点チェック。
    </div>
  </section>

  <!-- Slide 6: 疑問4 なぜ S を大きくしても単調に v が上がらないか -->
  <section class="slide">
    <h2>疑問4：なぜ S を大きくしても v(S) は単調に上がらないのか？</h2>
    <h3>直観的な誤解と修正</h3>
    <ul>
      <li>誤解：<br/>
        「S が大きい → 調整可能なビットが増える → いつも v(S) は増えるはず」</li>
      <li>修正：
        <ul>
          <li>NK ランドスケープは谷だらけで、ローカル探索は局所最適に捕まる。</li>
          <li>自由度が増えると「良い山にも悪い谷にも行きやすくなる」。</li>
        </ul>
      </li>
    </ul>
    <h3>原因1：相互依存（K）による非線形性</h3>
    <ul>
      <li>ビット同士が依存しているため、「単独で変えると悪化」「組み合わせると改善」などのパターンが大量に出る。</li>
      <li>ローカル探索は 1 ビットずつしか動かせないので、組み合わせ山頂に登れず、逆に悪い谷に落ちることもある。</li>
    </ul>
    <h3>原因2：探索空間の拡大とランダム性</h3>
    <ul>
      <li>S が大きいほど候補点数が爆発的に増え、「悪化方向」への試行も増える。</li>
      <li>その結果、期待値としての v(S) が <b>小さい S よりも低くなる</b>ケースも普通にありうる。</li>
    </ul>
    <div class="note">
      設計書レビューでは、「v(S) が |S| の単調増加を前提にしていないか」を確認する。<br/>
      NK モデルでは v の単調性は一般には成り立たない、という前提が重要。
    </div>
  </section>

  <!-- Slide 7: 疑問5 シナジー・アナジーの発生源 -->
  <section class="slide">
    <h2>疑問5：シナジー／アナジーはどこから生まれるか？</h2>
    <h3>ミクロレベル：局所相互依存構造 f_i</h3>
    <ul>
      <li>f_i(x_i, x_{J(i)}) が、特定の組み合わせでだけ急に高くなる → 相補性（シナジー）。</li>
      <li>逆に、特定の組み合わせだけ極端に低くなる → 競合性（アナジー）。</li>
      <li>これらは「f_i のパターン依存性」として埋め込まれている。</li>
    </ul>
    <h3>マクロレベル：制約付きローカル探索</h3>
    <ul>
      <li>提携 S が大きくなると、相互依存したビットを同時に動かせる → シナジーが顕在化しやすい。</li>
      <li>同時に、競合パターンにも入り込みやすくなる → アナジーが顕在化しやすい。</li>
      <li>この結果として、<code>v(S∪{i,j})</code> が <code>v(S∪{i}) + v(S∪{j}) - v(S)</code> から乖離し、シナジー／アナジーが測定可能になる。</li>
    </ul>
    <div class="note">
      あなたの Ordinal Synergy / Synergy–Anasy Distinction Axiom は、<br/>
      この「v の非線形性」を、序数情報ベースでどう識別・比較するかの枠組みになっている。
    </div>
  </section>

  <!-- Slide 8: 設計書レビューのチェックリスト -->
  <section class="slide">
    <h2>Copilot設計書レビュー用チェックポイント</h2>
    <h3>1. モデル構造</h3>
    <ul>
      <li>プレイヤ = ビットになっているか（「政策そのもの」になっていないか）。</li>
      <li>NK ランドスケープ（N, K, J(i), f_i）の定義が標準的か。</li>
      <li>F(x) が <code>(1/N) Σ f_i</code> の形で実装されているか。</li>
    </ul>
    <h3>2. v(S) の定義と実装</h3>
    <ul>
      <li>提携 S ごとに free_bits / fixed_bits が区別されているか。</li>
      <li>fixed_bits は baseline_x に固定されているか。</li>
      <li>ローカル探索は「1ビット反転＋山登り」で、最終 F(x_final) を M 回平均して v(S) を計算しているか。</li>
    </ul>
    <h3>3. 理論的前提</h3>
    <ul>
      <li>v(S) の単調増加性を前提にしたロジックが紛れ込んでいないか。</li>
      <li>シナジー／アナジーは「f_i の非線形性 × 制約付きローカル探索」の結果として扱われているか。</li>
    </ul>
    <div class="note">
      このスライド一式が、設計書レビュー時の「理想モデル仕様」として機能する想定。<br/>
      必要に応じて、このまま docs/ 以下の HTML に置き換えてもよい。
    </div>
  </section>

</div>
</body>
</html>