# CMIS NK Games

組織論で用いられる NK モデルを、複数の代表的な論文（Lazer2007 / Levinthal1997 / Ethiraj2004）に沿って実装し、
協力ゲームのゲームテーブル v(S) を生成するための実験基盤です。論文 PDF やモデリングスライド、設計書、ソースコードを
同一リポジトリ内で管理し、「仕様 ⇔ 実装 ⇔ 実験結果」が一望できる構成になっています。

## ディレクトリ構成

- `src/` – Python 実装（NK ランドスケープ、シナリオ別ダイナミクス、ゲームテーブル生成、CLI）。
- `docs/` – 論文 PDF・modeling.html・設計書などのドキュメント。
  - `docs/papers/` – 各論文の PDF / HTML スライド。
  - `docs/design/<scenario>/` – シナリオ別の要件定義・基本設計・詳細設計。
- `config/` – YAML 形式の実験設定ファイル（N, K, ネットワーク、ラウンド数、runs など）。
- `outputs/` – シミュレーション結果（ゲームテーブル CSV など）。Git 管理からは除外されています。

## 設計書（Design Docs）

実装は、シナリオごとに整理された設計書と 1 対 1 に対応するよう整理されています。

- Lazer2007: `docs/design/lazer2007/requirements.md`, `basic_design.md`, `detailed_design.md`
- Levinthal1997: `docs/design/levinthal1997/requirements.md`, `basic_design.md`, `detailed_design.md`
- Ethiraj2004: `docs/design/ethiraj2004/requirements.md`, `basic_design.md`, `detailed_design.md`

インデックスは `docs/README.md` を参照してください。これらは「NKモデル採用報告書」で定めた方針をコードレベルに落とし込んだもので、
アルゴリズム仕様（ステップ表）とクラス・関数名の対応が明示されています。

## 実行方法（CLI）

まず Poetry 環境をセットアップします（Python 3.11+）。

```bash
poetry install
```

### Lazer2007 ベースライン

```bash
poetry run nk-games run --config config/lazer2007_baseline.yml
```

- ネットワーク構造 × 探索/活用ダイナミクス（Lazer-Friedman 型）を再現し、
  プレイヤ = エージェント（= ビット担当者）の協力ゲーム v(S) を推定します。
  - プレイヤ: NK ビットを担当するエージェント。
  - v(S): 提携 S のみで構成されたネットワーク G[S] 上で、LF 型ダイナミクスを T ラウンド × R run 実行し、
    各 run における「最終ラウンド時点のエージェント平均フィットネス」の平均値として定義。
- 出力先（自動採番）: `outputs/tables/lazer2007/lazer2007_XXX.csv`
- `--output` で出力パスを直接指定できます。

### Levinthal1997 ベースライン

```bash
poetry run nk-games run --config config/levinthal1997_baseline.yml
```

- NK ランドスケープ上で、提携 S のみに設計自由度を与えた制約付きローカル探索を M 回実行し、
  プレイヤ = ビット（意思決定要素）の協力ゲーム v(S) を構成します。
  - プレイヤ: 各 NK ビット i（プレイヤ ID = ビットインデックス）。
  - v(S): 提携 S を「自由に変更可能なビット集合」とみなし、S 以外のビットをベースライン形態に固定したうえで、
    制約付きローカル探索を M 回実行し、各試行で到達したベストフィットネスの平均として定義。
- 出力先: `outputs/tables/levinthal1997/levinthal1997_XXX.csv`

### Ethiraj2004 ベースライン

```bash
poetry run nk-games run --config config/ethiraj2004_baseline.yml
```

- モジュール誤認（真のモジュール構造 vs デザイナー構造）を持つ NK モデル上で、複数企業の
  局所探索＋リコンビネーション動学を実行し、成熟設計 d* に基づくモジュール単位のゲームテーブル v(S) を生成します。
  - プレイヤ: モジュール（真のモジュール構造 or デザイナー構造のいずれか、config の `players_basis` で選択）。
  - v(S): R run のダイナミクスから得られる成熟設計 d*^(r) を用い、ベースライン設計 d⁰ に対して
    「S に属するモジュールだけ d*^(r) の値で上書きした設計 d^S^(r)」の F(d^S^(r)) を平均し、
    その期待値から F(d⁰) を引いた差 v(S) = E_r[F(d^S^(r))] − F(d⁰) として定義。
- 出力先: `outputs/tables/ethiraj2004/ethiraj2004_XXX.csv`

## 実世界での解釈（プレイヤーと v(S)）

数式上はどのシナリオも「プレイヤ集合 N」と「特性関数 v:2^N→ℝ」を扱いますが、
現実世界では次のような意味付けになります。

- **Lazer2007（ネットワーク構造 × 探索／活用）**
  - プレイヤ = 情報ネットワーク上の個人・役割（アイデアを持ち、他者を模倣／探索する主体）。
  - v(S) = 「そのメンバーだけで組織を構成したとき、ネットワーク内で情報をやり取りしながら問題解決に取り組むと、
    どの程度の水準の解（フィットネス）に到達できるか」という期待性能。
  - 例えば、S が「橋渡し役ばかり」「孤立ノードばかり」といった場合、その構造のままダイナミクスを回したときの
    問題解決能力を数値化して比較できます。

- **Levinthal1997（制約付きローカル探索）**
  - プレイヤ = 組織設計のビット（意思決定要素：ルール、プロセス、構造の 0/1 選択など）。
  - v(S) = 「S に含まれる設計要素だけを自由に変えられ、他の要素は固定された状態で山登り的改善を続けたとき、
    最終的にどの程度の性能まで持っていけるか」という“設計自由度としての貢献度”。
  - 現実には「この部署／役職にはどの設計レバーを握らせるべきか？」という問いに対して、
    そのレバー集合 S が持つ改善余地の大きさを v(S) で測っていると解釈できます。

- **Ethiraj2004（モジュール誤認と設計モジュールの貢献）**
  - プレイヤ = モジュール（真の技術的サブシステム、あるいは設計者が想定しているサブシステム単位）。
  - v(S) = 「ベースラインの初期設計 d⁰ から、S に属するモジュールだけを“うまく設計された状態”（成熟設計 d*）に
    切り替えたとき、システム全体の性能がどれだけ向上するか（F(d^S) − F(d⁰)）」を表す値。
  - これは、現実の製品開発で「どのモジュール群をきちんと設計すれば、全体性能がどれだけ伸びるか」を評価することに対応し、
    真のモジュール分割とデザイナーの誤ったモジュール分割のギャップが、貢献度評価にどう影響するかを調べるための指標になります。

## 今後の拡張のためのメモ

- `config/` に実験ケース（ネットワークタイプ、skill 差、conflict_pairs など）を追加することで、
  同じフレームワーク上で異なるシナリオ・パラメータのゲームテーブルを容易に比較できます。
- Shapley 値や相互作用指数の計算はこのリポジトリの外側（ノートブック等）で行う想定ですが、
  すべてのテーブルには scenario 名や N,K,seed などのメタ情報が `notes` カラムに埋め込まれているため、
  再現性の高い分析パイプラインが構成できます。
